<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TimeBox 3D</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>

#back-link {
    position: absolute;
    top: 24px;
    left: 24px;
    z-index: 50;
    opacity: 0.25;   /* ↓ lower = more transparent */
    transition: opacity 0.3s ease;
}

#back-link a {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 8px 16px;
    border-radius: 999px;
    font-size: 14px;
    text-decoration: none;
    color: rgba(255, 255, 255, 0.7);
    background: rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    transition: all 0.3s ease;
}

#back-link a:hover {
    color: #00ffff;
    background: rgba(255, 255, 255, 0.12);
    border-color: rgba(0, 255, 255, 0.5);
    transform: translateY(-2px);
}

#back-link .arrow {
    transition: transform 0.3s ease;
}

#back-link a:hover .arrow {
    transform: translateX(-4px);
}


        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Montserrat:wght@400;900&family=Orbitron:wght@400;900&family=Playfair+Display:wght@900&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Montserrat', sans-serif;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            transition: opacity 0.3s ease;
        }

        #settings-panel {
            background: rgba(15, 15, 15, 0.9);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            width: 280px;
            display: none; /* Hidden by default */
            margin-bottom: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-height: 80vh;
            overflow-y: auto;
        }

        /* Custom Scrollbar for panel */
        #settings-panel::-webkit-scrollbar {
            width: 6px;
        }
        #settings-panel::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 3px;
        }

        #settings-panel.active {
            display: block;
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #aaa;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
        }

        .control-group label span {
            color: #fff;
            font-weight: bold;
        }

        input[type="range"] {
            width: 100%;
            background: transparent;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            margin-top: -5px;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #444;
            border-radius: 2px;
        }

        select {
            width: 100%;
            padding: 8px;
            background: #222;
            border: 1px solid #444;
            color: #fff;
            border-radius: 4px;
            font-family: inherit;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: #777;
        }
        
        /* Color Picker Style */
        input[type="color"] {
            width: 100%;
            height: 35px;
            border: 1px solid #444;
            background: #222;
            cursor: pointer;
            padding: 2px;
            border-radius: 4px;
        }

        /* Seamless Glass Button */
        #toggle-btn {
            background: rgba(255, 255, 255, 0.02); /* Almost invisible initially */
            border: 1px solid rgba(255, 255, 255, 0.05); /* Very subtle rim */
            width: 56px; 
            height: 56px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); /* Smooth cinematic transition */
            backdrop-filter: blur(2px); /* Slight blur initially */
            opacity: 0.3; /* Mostly hidden */
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        #toggle-btn:hover {
            background: rgba(255, 255, 255, 0.15); /* Light glass on hover */
            border-color: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg) scale(1.1);
            backdrop-filter: blur(12px); /* Heavy frosted glass on hover */
            opacity: 1; /* Fully visible */
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5); /* Deep depth shadow */
        }

        #toggle-btn svg {
            fill: rgba(255, 255, 255, 0.6);
            width: 24px;
            height: 24px;
            transition: fill 0.3s;
        }

        #toggle-btn:hover svg {
            fill: #ffffff;
        }

        .hidden-ui #ui-layer {
            opacity: 0;
            pointer-events: none;
        }
        
        /* Loading Overlay */
        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff;
            z-index: 1000;
            transition: opacity 0.5s;
            font-family: 'Roboto Mono', monospace;
            letter-spacing: 2px;
        }
    </style>
</head>
<body>

    <div id="loader">INITIALIZING TIME...</div>

    <!-- Back Button -->
 <div id="back-link">
    <a href="/projects/">
        <span class="arrow">←</span>
        <span class="label">Back to Projects</span>
    </a>
</div>


    <div id="canvas-container"></div>

    <div id="ui-layer">

        <div id="settings-panel">

            <div class="control-group">
                <label>Theme Preset</label>
                <select id="preset-select"></select>
            </div>

            <div class="control-group">
                <label>Background Mode</label>
                <select id="bg-select">
                    <option value="default">Preset Default</option>
                    <option value="none">None (Static)</option>
                    <option value="custom">Custom Solid Color</option>
                    <option value="particles">Particles</option>
                    <option value="grid">Retro Grid</option>
                </select>
            </div>
            
            <div class="control-group" id="custom-color-group" style="display:none;">
                <label>Custom Color</label>
                <input type="color" id="bg-color-picker" value="#000000">
            </div>

            <div style="border-top: 1px solid #333; margin: 15px 0;"></div>
            
            <div class="control-group">
                <label>Camera Effects</label>
                <select id="camera-select">
                    <option value="fixed">Fixed (Interactive)</option>
                    <option value="orbit">Slow Orbit</option>
                    <option value="drift">Vantage Drift (Cinematic)</option>
                    <option value="spiral">Spiral Ascent</option>
                    <option value="heartbeat">Heartbeat Zoom</option>
                    <option value="handheld">Handheld</option>
                </select>
            </div>
            
            <div style="border-top: 1px solid #333; margin: 15px 0;"></div>

            <div class="control-group">
                <label>Rotation Speed</label>
                <input type="range" id="speed-slider" min="0" max="0.02" step="0.001">
            </div>
            <div class="control-group">
                <label>Cube Scale</label>
                <input type="range" id="scale-slider" min="0.5" max="2.5" step="0.1">
            </div>
             <div class="control-group">
                <label>Breathing Speed</label>
                <input type="range" id="breathing-slider" min="0" max="3" step="0.1">
            </div>
            
            <div style="border-top: 1px solid #333; margin: 15px 0;"></div>

            <div class="control-group">
                <label>Face Focus (Fade Sides)</label>
                <input type="range" id="focus-slider" min="0" max="10" step="0.5" value="4">
            </div>

            <div class="control-group">
                <label>Perspective (FOV)</label>
                <input type="range" id="fov-slider" min="30" max="120" step="1">
            </div>
            <div class="control-group">
                <label>Glow Intensity</label>
                <input type="range" id="glow-slider" min="0" max="1" step="0.1">
            </div>
            <div class="control-group">
                <label>Inactive Visibility</label>
                <input type="range" id="inactive-opacity-slider" min="0" max="1" step="0.05">
            </div>

            <div style="text-align: right; font-size: 0.65rem; color: #555; margin-top: 15px;">
                Drag to rotate • Scroll to zoom
            </div>
        </div>

        <button id="toggle-btn" title="Settings">
            <svg viewBox="0 0 24 24">
                <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.06-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.49l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.06,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
            </svg>
        </button>
    </div>

    <script>
        /**
         * CONFIGURATION & STATE
         */
        const PRESETS = {
            'Classic': {
                sceneBg: '#050505',
                cubeBg: '#222222', 
                inactive: '#555555',
                active: '#ffffff',
                font: 'Montserrat',
                shadow: false,
                bgType: 'particles',
                bgConfig: { color: 0x666666, count: 150, speed: 0.15, dir: 'float', size: 0.05, opacity: 0.3 }
            },
            'Cyberpunk': {
                sceneBg: '#020205',
                cubeBg: '#080814', 
                inactive: '#2a2a4e',
                active: '#00ffcc',
                font: 'Orbitron',
                shadow: true,
                shadowColor: '#d600ff',
                bgType: 'particles',
                bgConfig: { color: 0x00ffcc, count: 200, speed: 0.3, dir: 'float', size: 0.06, opacity: 0.25 }
            },
            'Vaporwave': {
                sceneBg: '#2b003b',
                cubeBg: '#1a002b',
                inactive: '#5e1c4e',
                active: '#00f9ff',
                font: 'Orbitron',
                shadow: true,
                shadowColor: '#ff009d',
                bgType: 'grid',
                bgConfig: { color: 0x550055, opacity: 0.3 }
            },
            'Golden Hour': {
                sceneBg: '#000000',
                cubeBg: '#110f00',
                inactive: '#3d3300',
                active: '#ffd700',
                font: 'Playfair Display',
                shadow: true,
                shadowColor: '#ffaa00',
                bgType: 'particles',
                bgConfig: { color: 0xffaa00, count: 180, speed: 0.2, dir: 'float', size: 0.06, opacity: 0.3 }
            },
            'Crimson Ops': {
                sceneBg: '#0a0000',
                cubeBg: '#1a0000',
                inactive: '#550000',
                active: '#ff0000',
                font: 'Orbitron',
                shadow: true,
                shadowColor: '#ff0000',
                bgType: 'particles',
                bgConfig: { color: 0xff0000, count: 200, speed: 0.4, dir: 'float', size: 0.06, opacity: 0.4 }
            },
            'Deep Sea': {
                sceneBg: '#001014',
                cubeBg: '#002b36',
                inactive: '#073642',
                active: '#2aa198',
                font: 'Montserrat',
                shadow: true,
                shadowColor: '#2aa198',
                bgType: 'particles',
                bgConfig: { color: 0x2aa198, count: 300, speed: 0.1, dir: 'float', size: 0.08, opacity: 0.2 }
            },
            'Paperback': {
                sceneBg: '#e6dfd1',
                cubeBg: '#e6dac3',
                inactive: '#bcaaa4',
                active: '#3e2723',
                font: 'Playfair Display',
                shadow: false,
                bgType: 'none'
            },
            'Matrix': {
                sceneBg: '#000000',
                cubeBg: '#001a00',
                inactive: '#003300',
                active: '#00ff00',
                font: 'Roboto Mono',
                shadow: true,
                shadowColor: '#00ff00',
                bgType: 'particles',
                bgConfig: { color: 0x00ff00, count: 300, speed: 0.8, dir: 'down', size: 0.07, opacity: 0.25 }
            },
            'Terminal': {
                sceneBg: '#000000',
                cubeBg: '#000000',
                inactive: '#1a1a1a',
                active: '#33ff00',
                font: 'Roboto Mono',
                shadow: true,
                shadowColor: '#33ff00',
                bgType: 'grid',
                bgConfig: { color: 0x003300, opacity: 0.4 }
            },
            'Velvet': {
                sceneBg: '#1a0005',
                cubeBg: '#300010',
                inactive: '#660022',
                active: '#ffccdd',
                font: 'Montserrat',
                shadow: true,
                shadowColor: '#ff0055',
                bgType: 'particles',
                bgConfig: { color: 0xff0055, count: 150, speed: 0.15, dir: 'float', size: 0.06, opacity: 0.3 }
            },
            'Ice Age': {
                sceneBg: '#e0f7fa',
                cubeBg: '#ffffff',
                inactive: '#b2ebf2',
                active: '#006064',
                font: 'Montserrat',
                shadow: false,
                shadowColor: '#00bcd4',
                bgType: 'particles',
                bgConfig: { color: 0xaaccff, count: 250, speed: 0.4, dir: 'down', size: 0.08, opacity: 0.4 }
            },
            'Blueprint': {
                sceneBg: '#000a1a',
                cubeBg: '#002b59',
                inactive: '#0055aa',
                active: '#ffffff',
                font: 'Roboto Mono',
                shadow: false,
                bgType: 'grid',
                bgConfig: { color: 0x003366, opacity: 0.3 }
            }
        };

        const GRID = [
            ["I","T","L","I","S","A","S","A","M","P","M"],
            ["A","C","Q","U","A","R","T","E","R","D","C"],
            ["T","W","E","N","T","Y","F","I","V","E","X"],
            ["H","A","L","F","S","T","E","N","F","T","O"],
            ["P","A","S","T","E","R","U","N","I","N","E"],
            ["O","N","E","S","I","X","T","H","R","E","E"],
            ["F","O","U","R","F","I","V","E","T","W","O"],
            ["E","I","G","H","T","E","L","E","V","E","N"],
            ["S","E","V","E","N","T","W","E","L","V","E"],
            ["T","E","N","S","E","O","C","L","O","C","K"]
        ];

        // Default state
        const state = {
            presetName: 'Classic',
            bgMode: 'default',
            customBgColor: '#000000',
            cameraMode: 'fixed', // fixed, orbit, drift, spiral, heartbeat, handheld
            rotationSpeed: 0.005,
            scale: 1.2,
            glow: 0.5,
            fov: 45,
            inactiveOpacity: 1.0,
            breathingSpeed: 1.0,
            faceFocus: 4.0,
            isDragging: false,
            previousMousePosition: { x: 0, y: 0 },
            targetRotation: { x: 0, y: 0 },
            manualRotation: { x: 0, y: 0 },
            forceRedraw: false
        };

        // Initialize Three.js variables
        let scene, camera, renderer, cubeGroup, cubeMesh;
        let bgGroup, bgParticles, bgGrid; 
        let clockInterval;
        let lastTimeStr = "";
        
        // Cinematic Camera State
        const cineParams = {
            target: new THREE.Vector3(0, 0, 5),
            current: new THREE.Vector3(0, 0, 5),
            lookAt: new THREE.Vector3(0, 0, 0),
            lerpSpeed: 0.008,
            angleY: 0,
            lastSwitchTime: 0
        };

        // Vantage Points for Drift Mode
        const VANTAGE_POINTS = [
            new THREE.Vector3(0, 0, 6),     // Front
            new THREE.Vector3(4, 3, 4),     // Top Right Corner
            new THREE.Vector3(-4, -2, 5),   // Bottom Left Corner
            new THREE.Vector3(0, 5, 2),     // Top Down
            new THREE.Vector3(-5, 1, 1),    // Side
            new THREE.Vector3(3, -4, 3)     // Low Angle
        ];

        // Face Normals
        const faceNormals = [
             new THREE.Vector3(1, 0, 0),  // Right
             new THREE.Vector3(-1, 0, 0), // Left
             new THREE.Vector3(0, 1, 0),  // Top
             new THREE.Vector3(0, -1, 0), // Bottom
             new THREE.Vector3(0, 0, 1),  // Front
             new THREE.Vector3(0, 0, -1)  // Back
        ];
        
        // Helper to get Canvas context for texture
        const canvasSize = 1024;
        const textCanvas = document.createElement('canvas');
        textCanvas.width = canvasSize;
        textCanvas.height = canvasSize;
        const ctx = textCanvas.getContext('2d');


        /**
         * INITIALIZATION
         */
        function init() {
            loadSettings();
            setupUI();
            
            // 1. Scene Setup
            scene = new THREE.Scene();
            
            // 2. Camera
            camera = new THREE.PerspectiveCamera(state.fov, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // 4. Background Group
            bgGroup = new THREE.Group();
            scene.add(bgGroup);

            // 5. Geometry & Group
            cubeGroup = new THREE.Group();
            scene.add(cubeGroup);

            const geometry = new THREE.BoxGeometry(3, 3, 3);
            
            // Texture
            const texture = new THREE.CanvasTexture(textCanvas);
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            texture.minFilter = THREE.LinearFilter;
            
            // Material - Using Basic material for "Screen" look
            const materials = Array(6).fill().map(() => new THREE.MeshBasicMaterial({ map: texture }));
            
            cubeMesh = new THREE.Mesh(geometry, materials);
            cubeGroup.add(cubeMesh);

            // 6. Events
            window.addEventListener('resize', onWindowResize, false);
            setupInteractions();

            // 7. Start Loop
            updateClockFace(); // Initial draw (also sets up BG)
            animate();
            
            // Hide Loader
            setTimeout(() => {
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').remove(), 500);
            }, 800);

            // Clock Tick Loop
            clockInterval = setInterval(updateClockFace, 1000);
        }

        /**
         * DYNAMIC BACKGROUNDS
         */
        function updateSceneBackground() {
            const preset = PRESETS[state.presetName];
            
            // Clear existing BG Elements
            while(bgGroup.children.length > 0){ 
                bgGroup.remove(bgGroup.children[0]); 
            }
            bgParticles = null;
            bgGrid = null;

            // Set Background Color
            if (state.bgMode === 'custom') {
                scene.background = new THREE.Color(state.customBgColor);
                return; 
            } else if (state.bgMode === 'none') {
                scene.background = new THREE.Color(preset.sceneBg);
                return; 
            } else {
                scene.background = new THREE.Color(preset.sceneBg);
            }

            let mode = state.bgMode;
            if (mode === 'default') {
                mode = preset.bgType || 'none';
            }

            // --- PARTICLES ---
            if (mode === 'particles') {
                const config = (state.bgMode === 'default') ? preset.bgConfig : { color: 0x888888, count: 200, speed: 0.2, dir: 'float', size: 0.05, opacity: 0.3 };
                if (!config) { config = { color: 0x888888, count: 200, speed: 0.2, dir: 'float', size: 0.05, opacity: 0.3 }; }
                
                const count = config.count || 200;
                const geom = new THREE.BufferGeometry();
                const posArray = new Float32Array(count * 3);
                const velArray = []; 

                for(let i=0; i<count * 3; i+=3) {
                    posArray[i] = (Math.random() - 0.5) * 20; 
                    posArray[i+1] = (Math.random() - 0.5) * 20; 
                    posArray[i+2] = (Math.random() - 0.5) * 10 - 5; 
                    
                    velArray.push({
                        y: -(Math.random() * (config.speed || 0.2) + 0.05),
                        x: (Math.random() - 0.5) * 0.02,
                        z: (Math.random() - 0.5) * 0.02
                    });
                }

                geom.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                
                const mat = new THREE.PointsMaterial({
                    size: config.size || 0.05,
                    color: config.color || 0xffffff,
                    transparent: true,
                    opacity: config.opacity || 0.3,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });

                bgParticles = new THREE.Points(geom, mat);
                bgParticles.userData = { velocities: velArray, config: config };
                bgGroup.add(bgParticles);
            }

            // --- GRID ---
            if (mode === 'grid') {
                 const config = (state.bgMode === 'default') ? preset.bgConfig : { color: 0x222222, opacity: 0.2 };
                 const color = config ? config.color : 0x222222;
                 const opacity = config && config.opacity ? config.opacity : 0.2;

                 bgGrid = new THREE.GridHelper(30, 30, color, color);
                 bgGrid.position.y = -4; 
                 bgGrid.position.z = -5; 
                 bgGrid.rotation.x = 0.1; 
                 
                 // Fade out grid
                 bgGrid.material.transparent = true;
                 bgGrid.material.opacity = opacity;
                 
                 bgGroup.add(bgGrid);
            }
        }

        function animateBackground() {
            if (bgParticles) {
                const positions = bgParticles.geometry.attributes.position.array;
                const vels = bgParticles.userData.velocities;
                const config = bgParticles.userData.config;

                for(let i=0; i < vels.length; i++) {
                    const idx = i * 3;
                    
                    if (config.dir === 'down') {
                        positions[idx+1] += vels[i].y;
                        if (positions[idx+1] < -10) {
                            positions[idx+1] = 10;
                        }
                    } else {
                        positions[idx] += Math.sin(Date.now() * 0.0005 + i) * 0.005;
                        positions[idx+1] += Math.cos(Date.now() * 0.0005 + i) * 0.005;
                    }
                }
                bgParticles.geometry.attributes.position.needsUpdate = true;
                bgParticles.rotation.y += 0.0002;
            }

            if (bgGrid) {
                bgGrid.position.z += 0.01;
                if (bgGrid.position.z > -4) {
                    bgGrid.position.z = -5; 
                }
            }
        }


        /**
         * WORD CLOCK LOGIC
         */
        function updateClockFace() {
            const now = new Date();
            let h = now.getHours();
            let m = now.getMinutes();
            let m5 = Math.round(m / 5) * 5;
            
            if (m5 > 30) h += 1;
            if (m5 === 60) m5 = 0;
            
            h = h % 12;
            if (h === 0) h = 12;

            const activeWords = ["IT", "IS"];

            if (m5 === 0) activeWords.push("OCLOCK");
            else if (m5 === 5) activeWords.push("FIVE", "PAST");
            else if (m5 === 10) activeWords.push("TEN", "PAST");
            else if (m5 === 15) activeWords.push("QUARTER", "PAST");
            else if (m5 === 20) activeWords.push("TWENTY", "PAST");
            else if (m5 === 25) activeWords.push("TWENTY", "FIVE", "PAST");
            else if (m5 === 30) activeWords.push("HALF", "PAST");
            else if (m5 === 35) activeWords.push("TWENTY", "FIVE", "TO");
            else if (m5 === 40) activeWords.push("TWENTY", "TO");
            else if (m5 === 45) activeWords.push("QUARTER", "TO");
            else if (m5 === 50) activeWords.push("TEN", "TO");
            else if (m5 === 55) activeWords.push("FIVE", "TO");

            const hoursMap = {
                1: "ONE", 2: "TWO", 3: "THREE", 4: "FOUR",
                5: "FIVE", 6: "SIX", 7: "SEVEN", 8: "EIGHT",
                9: "NINE", 10: "TEN", 11: "ELEVEN", 12: "TWELVE"
            };
            
            activeWords.push(hoursMap[h]);

            const timeStr = activeWords.join("-");
            
            if (timeStr !== lastTimeStr || state.forceRedraw) {
                if (state.forceRedraw) {
                     updateSceneBackground();
                }
                lastTimeStr = timeStr;
                state.forceRedraw = false;
                drawCanvas(activeWords);
            } else {
                 if (!bgGroup.children.length && state.bgMode !== 'none' && state.bgMode !== 'custom') {
                     updateSceneBackground();
                 }
            }
        }

        function drawCanvas(activeWords) {
            const currentPreset = PRESETS[state.presetName];
            
            if (state.bgMode === 'none') {
                 scene.background = new THREE.Color(currentPreset.sceneBg);
            }
            
            ctx.globalAlpha = 1.0;
            ctx.fillStyle = currentPreset.cubeBg;
            ctx.fillRect(0, 0, canvasSize, canvasSize);

            const cols = 11;
            const rows = 10;
            const cellW = canvasSize / cols;
            const cellH = canvasSize / rows;
            const fontSize = cellH * 0.75;
            
            ctx.font = `900 ${fontSize}px '${currentPreset.font}'`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let r = 0; r < rows; r++) {
                const rowChars = GRID[r];
                const rowString = rowChars.join("");
                let activeRanges = []; 
                
                activeWords.forEach(word => {
                    let index = rowString.indexOf(word);
                    if (index !== -1) {
                        let valid = false;
                        if (word === "IT" || word === "IS") { if (r === 0) valid = true; }
                        else if (word === "QUARTER") { if (r === 1) valid = true; }
                        else if (word === "TWENTY") { if (r === 2) valid = true; }
                        else if (word === "FIVE") { 
                            if (activeWords.includes("FIVE") && activeWords.length > 3 && r === 2) valid = true; 
                            else if ((activeWords.includes("PAST") || activeWords.includes("TO")) && !activeWords.includes("TWENTY") && r === 2) valid = true; 
                            else if (r === 6 && (!activeWords.includes("FIVE") || activeWords.includes("TWENTY") || (!activeWords.includes("PAST") && !activeWords.includes("TO")))) valid = true; 
                        }
                        else if (word === "HALF") { if (r === 3) valid = true; }
                        else if (word === "TEN") { 
                            if (r === 3 && (activeWords.includes("PAST") || activeWords.includes("TO"))) valid = true; 
                            if (r === 9 && !activeWords.includes("PAST") && !activeWords.includes("TO")) valid = true; 
                        }
                        else if (word === "PAST") { if (r === 4) valid = true; }
                        else if (word === "TO") { if (r === 3) valid = true; } 
                        else if (word === "NINE") { if (r === 4) valid = true; }
                        else if (word === "ONE") { if (r === 5) valid = true; }
                        else if (word === "SIX") { if (r === 5) valid = true; }
                        else if (word === "THREE") { if (r === 5) valid = true; }
                        else if (word === "FOUR") { if (r === 6) valid = true; }
                        else if (word === "TWO") { if (r === 6) valid = true; }
                        else if (word === "EIGHT") { if (r === 7) valid = true; }
                        else if (word === "ELEVEN") { if (r === 7) valid = true; }
                        else if (word === "SEVEN") { if (r === 8) valid = true; }
                        else if (word === "TWELVE") { if (r === 8) valid = true; }
                        else if (word === "OCLOCK") { if (r === 9) valid = true; }

                        if (valid) {
                            for(let i=0; i<word.length; i++) {
                                activeRanges.push(index + i);
                            }
                        }
                    }
                });

                for (let c = 0; c < cols; c++) {
                    const char = rowChars[c];
                    const x = c * cellW + cellW / 2;
                    const y = r * cellH + cellH / 2;
                    
                    const isActive = activeRanges.includes(c);

                    if (isActive) {
                        ctx.globalAlpha = 1.0;
                        ctx.fillStyle = currentPreset.active;
                        if (currentPreset.shadow) {
                            ctx.shadowColor = currentPreset.shadowColor;
                            ctx.shadowBlur = 30 * state.glow;
                        } else {
                             ctx.shadowBlur = 0;
                        }
                    } else {
                        ctx.globalAlpha = state.inactiveOpacity; 
                        ctx.fillStyle = currentPreset.inactive;
                        ctx.shadowBlur = 0;
                    }

                    ctx.fillText(char, x, y);
                }
            }
            
            if (cubeMesh) {
                cubeMesh.material.forEach(m => {
                    if (m.map) m.map.needsUpdate = true;
                });
            }
        }

        /**
         * CAMERA ANIMATION LOGIC
         */
        function updateCamera(time) {
            if (state.cameraMode === 'fixed') {
                camera.position.lerp(new THREE.Vector3(0,0,5), 0.05);
                camera.lookAt(0,0,0);
                camera.rotation.z = THREE.MathUtils.lerp(camera.rotation.z, 0, 0.05);
            }
            else if (state.cameraMode === 'orbit') {
                const radius = 5.5;
                const speed = 0.2;
                const angle = time * speed;
                
                camera.position.x = Math.sin(angle) * radius;
                camera.position.z = Math.cos(angle) * radius;
                camera.position.y = Math.sin(time * 0.5) * 1.0;
                
                camera.lookAt(0,0,0);
                camera.rotation.z = THREE.MathUtils.lerp(camera.rotation.z, 0, 0.05);
            }
            else if (state.cameraMode === 'spiral') {
                 // Spiral: Orbit with larger vertical movement
                 const radius = 6.0;
                 const speed = 0.3;
                 const angle = time * speed;
                 
                 camera.position.x = Math.sin(angle) * radius;
                 camera.position.z = Math.cos(angle) * radius;
                 // Large sinusoidal vertical movement
                 camera.position.y = Math.sin(time * 0.4) * 4.0; 
                 
                 camera.lookAt(0,0,0);
                 camera.rotation.z = THREE.MathUtils.lerp(camera.rotation.z, 0, 0.05);
            }
            else if (state.cameraMode === 'heartbeat') {
                // Heartbeat: Pulse Zoom
                // Create a heartbeat pattern: thump-thump... thump-thump
                const beat = (Math.sin(time * 3) + Math.sin(time * 3 + Math.PI*0.2) * 0.5);
                // Map beat to distance (inverted, closer on beat)
                const baseDist = 5.0;
                const zoomAmount = 0.5;
                const dist = baseDist - (beat * zoomAmount);
                
                camera.position.lerp(new THREE.Vector3(0, 0, dist), 0.1);
                camera.lookAt(0,0,0);
                camera.rotation.z = THREE.MathUtils.lerp(camera.rotation.z, 0, 0.05);
            }
            else if (state.cameraMode === 'handheld') {
                 // Handheld: Perlin-ish noise using multiple sin waves
                 const t = time * 0.5;
                 const x = Math.sin(t) * 0.5 + Math.sin(t * 2.1) * 0.2;
                 const y = Math.cos(t * 1.3) * 0.5 + Math.sin(t * 3.4) * 0.2;
                 const z = 5 + Math.sin(t * 0.7) * 0.3;
                 
                 camera.position.lerp(new THREE.Vector3(x, y, z), 0.05);
                 camera.lookAt(0,0,0);
                 
                 // Slight roll
                 const roll = Math.sin(t * 0.8) * 0.05;
                 camera.rotation.z = THREE.MathUtils.lerp(camera.rotation.z, roll, 0.05);
            }
            else if (state.cameraMode === 'drift') {
                const dist = camera.position.distanceTo(cineParams.target);
                
                if (dist < 0.5 || (Date.now() - cineParams.lastSwitchTime > 12000)) {
                     const nextIdx = Math.floor(Math.random() * VANTAGE_POINTS.length);
                     cineParams.target.copy(VANTAGE_POINTS[nextIdx]);
                     cineParams.lastSwitchTime = Date.now();
                     
                     cineParams.target.x += (Math.random()-0.5);
                     cineParams.target.y += (Math.random()-0.5);
                }
                
                camera.position.lerp(cineParams.target, cineParams.lerpSpeed);
                camera.lookAt(0,0,0);
                
                const targetRoll = camera.position.x * -0.05; 
                camera.rotation.z = THREE.MathUtils.lerp(camera.rotation.z, targetRoll, 0.02);
            }
        }

        /**
         * ANIMATION LOOP
         */
        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            animateBackground();

            // Auto Rotation of CUBE (Only in Fixed mode, or generally slower in others?)
            let effectiveSpeed = state.rotationSpeed;
            if (state.cameraMode !== 'fixed') effectiveSpeed *= 0.5; // Slow down cube spin in cinematic modes

            if (!state.isDragging) {
                cubeGroup.rotation.x += effectiveSpeed;
                cubeGroup.rotation.y += effectiveSpeed;
            }

            // Bobbing & Breathing
            cubeGroup.position.y = Math.sin(time * state.breathingSpeed) * 0.2; 
            const breathing = 1 + Math.sin(time * state.breathingSpeed * 0.5) * 0.02;
            const finalScale = state.scale * breathing;
            cubeGroup.scale.setScalar(THREE.MathUtils.lerp(cubeGroup.scale.x, finalScale, 0.1));

            // Camera Logic
            updateCamera(time);

            // FOV Update
            if (camera.fov !== state.fov) {
                camera.fov = state.fov;
                camera.updateProjectionMatrix();
            }

            // DYNAMIC FACE FADING
            if (cubeMesh && cubeMesh.material) {
                cubeMesh.material.forEach((mat, idx) => {
                    // World Normal
                    const normal = faceNormals[idx].clone().applyQuaternion(cubeGroup.quaternion);
                    const viewVector = new THREE.Vector3().subVectors(camera.position, cubeGroup.position).normalize();
                    let intensity = normal.dot(viewVector);
                    
                    if (intensity < 0) intensity = 0;
                    intensity = Math.pow(intensity, state.faceFocus);
                    mat.color.setScalar(intensity);
                });
            }

            renderer.render(scene, camera);
        }

        /**
         * UI & SETTINGS
         */
        function setupUI() {
            const panel = document.getElementById('settings-panel');
            const btn = document.getElementById('toggle-btn');
            
            btn.addEventListener('click', () => {
                panel.classList.toggle('active');
            });

            // Presets
            const presetSelect = document.getElementById('preset-select');
            Object.keys(PRESETS).forEach(key => {
                const opt = document.createElement('option');
                opt.value = key;
                opt.innerText = key;
                if (key === state.presetName) opt.selected = true;
                presetSelect.appendChild(opt);
            });

            presetSelect.addEventListener('change', (e) => {
                state.presetName = e.target.value;
                state.bgMode = 'default';
                document.getElementById('bg-select').value = 'default';
                document.getElementById('custom-color-group').style.display = 'none';
                state.forceRedraw = true;
                updateClockFace();
            });

            // Background Mode
            const bgSelect = document.getElementById('bg-select');
            const colorGroup = document.getElementById('custom-color-group');
            
            bgSelect.addEventListener('change', (e) => {
                state.bgMode = e.target.value;
                if (state.bgMode === 'custom') {
                    colorGroup.style.display = 'block';
                } else {
                    colorGroup.style.display = 'none';
                }
                state.forceRedraw = true;
                updateClockFace();
                saveSettings();
            });
            
            const colorPicker = document.getElementById('bg-color-picker');
            colorPicker.addEventListener('input', (e) => {
                state.customBgColor = e.target.value;
                if (state.bgMode === 'custom') {
                    scene.background = new THREE.Color(state.customBgColor);
                }
                saveSettings();
            });

            // Camera Mode
            const camSelect = document.getElementById('camera-select');
            camSelect.addEventListener('change', (e) => {
                state.cameraMode = e.target.value;
                saveSettings();
            });

            // Sliders
            const bindSlider = (id, key, needsRedraw = false) => {
                const el = document.getElementById(id);
                el.value = state[key];
                el.addEventListener('input', (e) => {
                    state[key] = parseFloat(e.target.value);
                    if (needsRedraw) {
                        state.forceRedraw = true;
                        updateClockFace();
                    }
                    saveSettings();
                });
            };

            bindSlider('speed-slider', 'rotationSpeed');
            bindSlider('scale-slider', 'scale');
            bindSlider('breathing-slider', 'breathingSpeed');
            bindSlider('focus-slider', 'faceFocus');
            bindSlider('fov-slider', 'fov');
            bindSlider('glow-slider', 'glow', true);
            bindSlider('inactive-opacity-slider', 'inactiveOpacity', true);
        }

        function loadSettings() {
            const saved = localStorage.getItem('wordClockSettings');
            if (saved) {
                const parsed = JSON.parse(saved);
                state.rotationSpeed = parsed.rotationSpeed ?? 0.005;
                state.scale = parsed.scale ?? 1.2;
                state.glow = parsed.glow ?? 0.5;
                state.fov = parsed.fov ?? 45;
                state.inactiveOpacity = parsed.inactiveOpacity ?? 1.0;
                state.breathingSpeed = parsed.breathingSpeed ?? 1.0;
                state.faceFocus = parsed.faceFocus ?? 4.0;
                state.bgMode = parsed.bgMode ?? 'default';
                state.customBgColor = parsed.customBgColor ?? '#000000';
                state.cameraMode = parsed.cameraMode ?? 'fixed';
            }
            
            const keys = Object.keys(PRESETS);
            state.presetName = keys[Math.floor(Math.random() * keys.length)];
            
            // Sync UI state
            document.getElementById('bg-select').value = state.bgMode;
            document.getElementById('bg-color-picker').value = state.customBgColor;
            document.getElementById('camera-select').value = state.cameraMode;
            if (state.bgMode === 'custom') {
                document.getElementById('custom-color-group').style.display = 'block';
            }
        }

        function saveSettings() {
            const toSave = {
                rotationSpeed: state.rotationSpeed,
                scale: state.scale,
                glow: state.glow,
                fov: state.fov,
                inactiveOpacity: state.inactiveOpacity,
                breathingSpeed: state.breathingSpeed,
                faceFocus: state.faceFocus,
                bgMode: state.bgMode,
                customBgColor: state.customBgColor,
                cameraMode: state.cameraMode
            };
            localStorage.setItem('wordClockSettings', JSON.stringify(toSave));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * MOUSE/TOUCH INTERACTIONS
         */
        function setupInteractions() {
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            const onDown = (e) => {
                if (e.target.closest('#ui-layer')) return;
                
                state.isDragging = true;
                isDragging = true;
                previousMousePosition = {
                    x: e.clientX || e.touches[0].clientX,
                    y: e.clientY || e.touches[0].clientY
                };
            };

            const onMove = (e) => {
                if (!isDragging) return;
                
                const currentX = e.clientX || e.touches[0].clientX;
                const currentY = e.clientY || e.touches[0].clientY;

                const deltaMove = {
                    x: currentX - previousMousePosition.x,
                    y: currentY - previousMousePosition.y
                };

                // In fixed mode, drag rotates the CUBE.
                // In Orbit/Drift, does drag control camera or cube?
                // Let's stick to rotating the cube for consistency, 
                // but maybe we should disable it for drift mode to keep it "Cinematic".
                // Current code: rotates cubeGroup.
                
                if (state.cameraMode === 'fixed') {
                    cubeGroup.rotation.y += deltaMove.x * 0.005;
                    cubeGroup.rotation.x += deltaMove.y * 0.005;
                }

                previousMousePosition = { x: currentX, y: currentY };
            };

            const onUp = () => {
                state.isDragging = false;
                isDragging = false;
            };

            document.addEventListener('mousedown', onDown);
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
            
            document.addEventListener('touchstart', onDown, {passive: false});
            document.addEventListener('touchmove', onMove, {passive: false});
            document.addEventListener('touchend', onUp);
        }

        init();

    </script>
</body>
</html>